package main

import (
	"fmt"
	"math"
)

// LeetCode 209.长度最小的子数组
//给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，
//并返回其长度。如果不存在符合条件的子数组，返回 0。

//示例：
//输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

//方法1：暴力解法
//这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)，
// 空间复杂度：O(1)

//方法2:滑动窗口-官方
// 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。

//其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，
//所以叫做滑动窗口更适合一些。

//在本题中实现滑动窗口，主要确定如下三点：
// 窗口内是什么？
// 如何移动窗口的起始位置？
// 如何移动窗口的结束位置？

//窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。
//窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。
//窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

//可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。
//从而将O(n^2)暴力解法降为O(n)。

//时间复杂度：O(n)，其中 nn 是数组的长度。指针 start 和 end 最多各移动 nn 次。
//空间复杂度：O(1)。
func f1(s int, nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	ans := math.MaxInt32
	start, end := 0, 0
	sum := 0
	for end < n {
		sum += nums[end]
		for sum >= s {
			ans = min(ans, end-start+1)
			sum -= nums[start]
			start++
		}
		end++
	}
	if ans == math.MaxInt32 {
		return 0
	}
	return ans
}
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

func main() {
	target := 7
	arr := []int{1, 3, 6, 4, 2}
	fmt.Println(f1(target, arr))
}
