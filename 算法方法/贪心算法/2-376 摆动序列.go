package main

import "fmt"

//LeetCode 376. 摆动序列

//如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）
// 可能是正数或负数。少于两个元素的序列也是摆动序列。

//例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5]
// 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

//给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，
// 剩下的元素保持其原始顺序。

//示例 1:
//输入: [1,7,4,9,2,5]
//输出: 6
//解释: 整个序列均为摆动序列。

// 卡尔
//本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

//来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？

//局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
//整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。

//局部最优推出全局最优，并举不出反例，那么试试贪心！

//（为方便表述，以下说的峰值都是指局部峰值）
//实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了
// （相当于是删除单一坡度上的节点，然后统计长度）
//这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点。

func wiggleMaxLength33(nums []int) int {
	var count, preDiff, curDiff int
	count = 1 // 默认至少有一个
	if len(nums) < 2 {
		return count
	}

	for i := 0; i < len(nums)-1; i++ {
		curDiff = nums[i+1] - nums[i]
		//如果有正有负则更新下标值||或者只有前一个元素为0（针对两个不等元素的序列也视作摆动序列，且摆动长度为2）
		if (curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0) {
			preDiff = curDiff
			count++
		}
	}

	return count
}

func main() {
	arr := []int{1, 17, 5, 10, 13, 15, 10, 5, 16, 8}
	fmt.Println(wiggleMaxLength33(arr))

}

// 官方
// https://leetcode.cn/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
