package main

//LeetCode 70. 爬楼梯

//假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

//每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

//注意：给定 n 是一个正整数。

//示例 1：
//输入： 2
//输出： 2
//解释： 有两种方法可以爬到楼顶。
//1 阶 + 1 阶
//2 阶

//思路
//1 确定dp数组以及下标的含义
// dp[i]： 爬到第i层楼梯，有dp[i]种方法

//2 确定递推公式
//从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。
// 1 dp[i - 1]，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。
// 2 dp[i - 2]，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。
// 因为走到dp[i]时，要么是dp[i - 1]走一步(1个台阶)过来的，要么是dp[i - 2]走一步(两个台阶)过来的
// （其中dp[i - 2]不能走两步(没步一个台阶)，因为会和dp[i - 1]走一步重复）

//所以dp[i] = dp[i - 1] + dp[i - 2] 。

//3 dp初始化
//大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，
// 然后就往结果上靠去解释dp[0] = 1。
//从dp数组定义的角度上来说，dp[0] = 0 也能说得通。

// 4 确定遍历顺序-从前到后

// 5 举例推导dp数组

// 其实和斐波那契类似
func climbStairs(n int) int {
	if n == 1 {
		return 1
	}
	dp := make([]int, n+1)
	dp[1] = 1
	dp[2] = 2
	for i := 3; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}

//官方
//https://leetcode.cn/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/
